///////////////////////////////////////////////////////////////////////////////
/// @fn luxSend 1
/// @brief Send a single command
/// @param[in] command.command.txt
///////////////////////////////////////////////////////////////////////////////
prints commands.command.txt,0
printh 0A
ok=0

// Scroll up
strlen commands.history.txt,send_historyLen 
strlen commands.command.txt,send_newCmdLen
send_newBufLen=send_historyLen+send_newCmdLen
if(send_newBufLen>=commands.history.txt_maxl) //Check if reached buffer lenght
{
  //Cut lenght of new command out of buffer
  substr commands.history.txt,vars.s.txt,send_newCmdLen,send_historyLen-send_newCmdLen
  commands.history.txt=vars.s.txt
  //Find length until next \r
  spstr  commands.history.txt,vars.s.txt,"\r",0
  strlen vars.s.txt,send_trimLen
  //Cut that out of the rest of the buffer
  //+1 is to advance cursor
  substr commands.history.txt,vars.s.txt,send_trimLen+1,
  
  
  
  substr commands.history.txt,vars.s.txt,send_fstCmdLen+1,send_historyLen-send_fstCmdLen  //Substring of history without first command, +1 to advance cursor
  commands.history.txt=vars.s.txt
}

commands.history.txt+=commands.command.txt
commands.history.txt+="\r"
commands.last.txt=commands.command.txt
commands.command.txt=""

///////////////////////////////////////////////////////////////////////////////
/// @fn luxSend 0
/// @brief Send command queue, waiting for ok between each command
/// @brief Waits a max of 10 times for each ok
///////////////////////////////////////////////////////////////////////////////
if(busy==1) //Clear busy status every 5 seconds
{
  BusyCycles++
  if(BusyCycles>50) //50 * 100ms run timer = 5 seconds
  {
    busy=0
    BusyCycles=0
  }
}else
{
  BusyCycles=0
}
if(ok==0) //Track how many time ok was not recieved
{
  OkBlocks+=1
  if(OkBlocks>OkFailsafe) //Failsafe, try and trigger an ok
  {
    commands.command.txt="M118"
    click luxSend,1
    OkBlocks=0
  }
}else
{
  OkBlocks=0
}
strlen commands.queue.txt,QueueLen //get the length of the command queue
if(ok==1&&busy==0) //Send Queue
{
  OkBlocks=0
  while(QueueLen>0&&OkBlocks<MaxOKBlocks)
  {
    doevents
    click luxRead,1
    if(ok==1&&busy==0)
    {
      spstr commands.queue.txt,vars.s.txt,"\r",0
      if(vars.s.txt!="")
      {
        strlen vars.s.txt,CommandLen //get the lenght of the command
        CharLen=QueueLen-CommandLen //calc the amount of chars to copy
        //remove the command from the queue by getting a substring of the commandqueue
        substr commands.queue.txt,commands.queue.txt,CommandLen+2,CharLen+1 //+2 to count \r
        commands.command.txt=vars.s.txt
        click luxSend,1
      }else
      {
        commands.queue.txt=""
        QueueLen=0
      }
    }else
    {
      OkBlocks+=1
      delay=10
    }
    strlen commands.queue.txt,QueueLen //Refresh the command queue lenght
  }
}